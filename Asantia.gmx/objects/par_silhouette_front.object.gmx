<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>item_example</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>This Object should be parented to the foreground objects, but can function on it's own.</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Variable declarations &amp; Surface Creation
xsize=sprite_get_width(sprite_index)*image_xscale;//The width of the sprite/surface.
ysize=sprite_get_height(sprite_index)*image_yscale;//The height of the sprite/surface.

ob[500]=0;// Array used to count objects.

draw_alpha=0.8 //the default level of opacity
draw_col=c_black; // the defalut colour to draw the silhouette
sprite_masking=0;// This variable is used to define whether you want to use sprite masking for the silhouettes, if this is false, it will use the entire surface. Useful for keeping things efficient with walls.


silo_sf = surface_create(xsize, ysize);//Surface creation.



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Masking &amp; Silhouetting.

if (sprite_masking) {
    draw_sprite_ext(sprite_index  ,image_index  ,x  ,y  ,image_xscale  ,image_yscale  ,image_angle  ,c_white  ,1);    //Draw the obscuring object if you want to make the silhouette masked by the obscuring object.
}

cols=0;     //Resetting counting variable.
with par_silhouette_back //This can be changed to your background object parent name.
{
    if collision_rectangle(other.x-other.sprite_xoffset  ,other.y-other.sprite_yoffset  ,other.x-other.sprite_xoffset+other.xsize  ,other.y-other.sprite_yoffset+other.ysize  ,id  ,0  ,0  ) &amp;&amp; (depth&gt;other.depth)    //Checking to see how many silhouette objects are inside boundaries, and deeper than the obscuring object.
    {
        other.ob[other.cols]=id;    //Collecting IDs.
        other.cols+=1;  //Increase counting variable.
    }
}

if cols&gt;0 //If there is any silhouette object inside
{

    if !surface_exists(silo_sf) 
    {
        silo_sf = surface_create(xsize, ysize); //Making sure surface exists
    }
    
    surface_set_target(silo_sf);
    
    draw_clear_alpha(c_black  ,0); //clearing surface to RGBA(0,0,0,0)
    
    if (sprite_masking) //if we are using sprite masking
    {
    
        draw_sprite_ext(sprite_index  ,image_index  ,sprite_xoffset  ,sprite_yoffset  ,image_xscale  ,image_yscale  ,image_angle  ,c_white  ,1); //Draw the obscuring object in preparation for blending.
        
        draw_set_blend_mode_ext(7  ,6) //Source=7 (= bm_dest_alpha) and Destination=6 (= bm_inv_src_alpha)
    
        /*
        Extended blend modes work by affecting chosen components of the colour that's to be drawn (known as the source) by a factor,
        and then affecting the chosen components of the colour that's already there (known as the destination) by a factor,
        and multiplying the new source and destination together for the resulting colour.

        Since we only need to affect alpha, the following shows a basic example of how this works using 1 as pixels with full alpha and 0 as pixels no alpha.
        
            Scenario 1:
            
            0000 &lt;---source
            0110
            0110
            0000
            
            0000 &lt;---destination
            0000
            0000
            0000
            
            0000 &lt;---source with bm_dest_alpha applied
            0000
            0000
            0000
             *
            0000 &lt;---destination with bm_inv_src_alpha applied
            0000
            0000
            0000
             =
            0000 &lt;---what's displayed
            0000
            0000
            0000
            
            Scenario 2:
            
            0000 &lt;---source
            0000
            0000
            0000
            
            0000 &lt;---destination
            0110
            0110
            0000
            
            0000 &lt;---source with bm_dest_alpha applied
            0000
            0000
            0000
             *
            0000 &lt;---destination with bm_inv_src_alpha applied
            0110
            0110
            0000
             =
            0000 &lt;---what's displayed
            0000
            0000
            0000
        
        
            Scenario 3:
            
            0000 &lt;---source
            0110
            0110
            0000
            
            0000 &lt;---destination
            0110
            0110
            0000
            
            0000 &lt;---source with bm_dest_alpha applied
            0110
            0110
            0000
             *
            0000 &lt;---destination with bm_inv_src_alpha applied
            0110
            0110
            0000
             =
            0000 &lt;---what's displayed
            0110
            0110
            0000
        
            Scenario 4:
            
            0000 &lt;---source
            0011
            0011
            0000
            
            0000 &lt;---destination
            0110
            0110
            0000
            
            0000 &lt;---source with bm_dest_alpha applied
            0010
            0010
            0000
             *
            0000 &lt;---destination with bm_inv_src_alpha applied
            0010
            0010
            0000
             =
            0000 &lt;---what's displayed
            0010
            0010
            0000
            */
    }
    
    ix=0; // reset counting variable
    repeat(cols) //for every object that is inside
    {
        draw_sprite_ext(ob[ix].sprite_index,ob[ix].image_index  ,ob[ix].x-(x-sprite_xoffset),ob[ix].y-(y-sprite_yoffset),ob[ix].image_xscale  ,ob[ix].image_yscale,ob[ix].image_angle  ,draw_col ,1); // draw their sprite at their relative position in the colour 'draw_col' defined in the object creation 
        ix+=1 //increase counting variable
    }
    
    draw_set_blend_mode(bm_normal); // reset blend mode
    surface_reset_target(); // reset surface target
    
    draw_surface_ext(silo_sf  ,x-sprite_xoffset  ,y-sprite_yoffset  ,1  ,1  ,0  ,c_white  ,draw_alpha); // draw the surface in the correct location
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
